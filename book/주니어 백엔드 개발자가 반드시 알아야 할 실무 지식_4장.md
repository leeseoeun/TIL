# 4장 외부 연동이 문제일 때 살펴봐야 할 것들
## 우리는 문제가 없는데

<br>

## 타임아웃
- A 서비스는 톰캣을 사용하고 있으며 스레드 풀 크기는 200이다. 즉, A 서비스는 동시에 200개의 요청을 처리할 수 있다. **(91)**

<br>

톰캣에서는 스레드 한 개가 하나의 요청을 처리합니다.

<br>

**자세히 설명하자면:**
- 톰캣은 요청-응답 처리 모델에서, 각 HTTP 요청이 들어오면 워커 스레드 하나를 할당해서 해당 요청을 처리합니다.
- 그 스레드는 요청을 처리하는 동안 다른 요청을 처리하지 못합니다.<br>
즉, 하나의 스레드는 오직 하나의 요청을 담당합니다.

<br>

**예시로 보면:**
- 스레드 풀에 200개의 스레드가 있다면,
    - 동시에 200개의 요청이 오면 → 각각의 요청은 각각의 스레드에서 병렬로 처리됨.
    - 201번째 요청이 오면 → 빈 스레드가 없으므로, 요청은 대기 상태(request queue)에 들어감.
    - 어떤 스레드가 처리 완료되면 → 다음 대기 중인 요청을 처리.

<br>

**참고로, 이 구조의 특징은:**
- 동기 방식 처리에 적합 (기본적인 Servlet 방식)
- 스레드 하나가 요청의 전체 수명 주기를 담당
    - 컨트롤러 진입, 서비스 로직 처리, DB 접근, 뷰 반환 등

<br>

**추가 정보 (비동기 방식이 궁금하다면):**<br>
만약 Async Servlet, WebFlux (Reactive) 같은 기술을 사용하면 스레드 사용 방식이 달라집니다.<br>
이 경우는 논블로킹 방식으로, 하나의 스레드가 여러 요청을 효율적으로 처리할 수 있게 되죠.<br>
하지만 일반적인 톰캣 기반(Spring MVC 등)은 스레드 1개 : 요청 1개 구조입니다.

<br>

**결론:**
> 톰캣에서는 스레드 하나가 하나의 요청만 처리합니다.
요청을 다 처리하고 응답을 반환한 후에야 스레드는 다음 요청을 처리할 수 있게 됩니다.

<br>

### 2가지 타임아웃: 연결 타임아웃, 읽기 타임아웃
- 소켓 타임아웃과 읽기 타임아웃 **(95)**

<br>

소켓 타임아웃(Socket Timeout)과 읽기 타임아웃(Read Timeout)은 네트워크 통신에서 응답 지연이나 끊김 상황에 대처하기 위한 설정입니다.<br>
두 개념은 유사하지만 타이밍과 상황이 다릅니다. 아래에 쉽게 정리해 드릴게요.

<br>

**✅ 1. 소켓 타임아웃 (Socket Timeout)**<br>
의미:
- 전체 통신 과정에서 일정 시간 내에 응답이 없으면 연결을 끊는 시간 제한입니다.
- 연결된 이후, 데이터 송수신을 포함한 전체 작업 시간에 적용됩니다.

<br>

예시 상황:
- 서버와 클라이언트가 연결은 됐지만, 서버가 너무 늦게 응답하거나 멈춰 있음.
- 클라이언트는 지정된 시간 안에 응답이 오지 않으면 예외(TimeoutException)를 발생시킴.

<br>

Java 예시:
```java
socket.setSoTimeout(5000); // 5초 동안 응답 없으면 SocketTimeoutException
```

<br>

**✅ 2. 읽기 타임아웃 (Read Timeout)**<br>
의미:
- 서버와 연결은 되어 있고 요청도 보냈는데,
- 서버의 응답 데이터(body)를 읽는 과정 중 일정 시간 동안 아무 데이터도 도착하지 않으면 타임아웃 발생.

<br>

예시 상황:
- 서버가 응답을 시작하긴 했지만, 중간에 멈추거나 너무 느리게 전송 중.
- 스트리밍 데이터나 큰 파일 다운로드 시 유용함.

<br>

Spring RestTemplate 설정 예시:
```java
HttpComponentsClientHttpRequestFactory factory = new HttpComponentsClientHttpRequestFactory();
factory.setReadTimeout(5000); // 5초간 읽기 대기 후 예외
```

<br>

**✅ 차이 요약 비교표:**
| 항목 | 소켓 타임아웃 (Socket Timeout) | 읽기 타임아웃 (Read Timeout) |
| --- | --- | --- |
| 적용 시점 | 전체 통신 (연결 후 요청~응답 전체) | 응답 데이터를 읽는 중 |
| 타임아웃 조건 | 일정 시간 내 응답 자체가 없음 | 읽는 도중 일정 시간 동안 데이터가 안 옴 |
| 용도 | 서버가 아예 반응이 없을 때 | 데이터 일부 받고 멈춘 경우 대응 |
| 예외 | `SocketTimeoutException` | `SocketTimeoutException` (같은 예외지만 원인이 다름) |

<br>

**✅ 참고: 연결 타임아웃 (Connect Timeout)도 있어요!**
| 항목 | 연결 타임아웃 (Connect Timeout) |
| --- | --- |
| 적용 시점 | 서버에 연결을 시도하는 순간 |
| 용도 | 서버가 아예 접속 불가할 때 (포트 닫힘 등) |
| 예시 | 서버가 꺼져 있음, 방화벽 차단 등 |

<br>

**✅ 결론 요약:**
> - 소켓 타임아웃: 전체 응답이 안 오면 끊는다.
> - 읽기 타임아웃: 응답 도중 멈추면 끊는다.

<br>

둘 다 네트워크 문제나 서버 지연에 대비해 어플리케이션이 무한정 대기하지 않도록 보호하는 역할을 합니다.<br>
실제 서비스에서는 세 가지 타임아웃 (연결, 읽기, 소켓)을 모두 적절히 설정해 주는 게 좋습니다.

<br>

아래는 Apache HttpClient와 OkHttp 라이브러리 기준으로
연결 타임아웃, 소켓 타임아웃, 읽기 타임아웃의 차이를 각각 설명한 것입니다.

<br>

**✅ 1. Apache HttpClient 기준**
```java
RequestConfig config = RequestConfig.custom()
    .setConnectTimeout(3000)      // 연결 타임아웃 (서버 연결 시도 제한 시간)
    .setSocketTimeout(5000)       // 소켓(읽기) 타임아웃 (응답 받는 동안 대기 시간)
    .setConnectionRequestTimeout(2000) // 커넥션 풀에서 커넥션 얻기까지 기다리는 시간
    .build();

CloseableHttpClient client = HttpClients.custom()
    .setDefaultRequestConfig(config)
    .build();
```

<br>

**🔹 설명:**
| 항목 | 의미 |
| --- | --- |
| `connectTimeout` | 서버 연결을 시도할 때 최대 대기 시간 (예: 서버가 꺼져 있음) |
| `socketTimeout` | 요청 후 응답을 기다리는 최대 시간 = 읽기 타임아웃 |
| `connectionRequestTimeout` | 커넥션 풀에서 커넥션을 빌려오기까지 기다리는 시간 |
> ❗ Apache HttpClient에서는 "소켓 타임아웃" = "읽기 타임아웃"이라는 점이 핵심입니다.

<br>

**✅ 2. OkHttp 기준**
```java
OkHttpClient client = new OkHttpClient.Builder()
    .connectTimeout(3, TimeUnit.SECONDS) // 연결 타임아웃
    .readTimeout(5, TimeUnit.SECONDS)    // 읽기 타임아웃 (응답 Body 수신 시간 제한)
    .writeTimeout(2, TimeUnit.SECONDS)   // 쓰기 타임아웃 (요청 Body 전송 시간 제한)
    .build();
```

<br>

**🔹 설명:**
| 항목 | 의미 |
| --- | --- |
| `connectTimeout` | 서버 연결 시도 제한 시간 (TCP 연결까지)
| `readTimeout` | 응답을 읽는 중 아무 데이터도 안 오면 끊음 = 읽기 타임아웃 |
| `writeTimeout` | 요청 바디를 서버로 보내는 데 시간이 오래 걸릴 경우 제한 |
> ❗ OkHttp는 `readTimeout`과 `writeTimeout`을 명확히 구분하며,
`readTimeout`이 Apache의 `socketTimeout`과 같은 역할을 합니다.

<br>

**✅ 차이 요약 비교 (Apache vs OkHttp)**
| 구분 | Apache HttpClient | OkHttp |
| --- | --- | --- |
| 연결 타임아웃 | `connectTimeout` | `connectTimeout` |
| 읽기 타임아웃 | `socketTimeout` | `readTimeout` |
| 쓰기 타임아웃 | 없음 (자동 처리) | `writeTimeout` |
| 커넥션 풀 타임아웃 | `connectionRequestTimeout` | 없음 (내부 처리) |

<br>

**✅ 상황별 예시**
| 상황 | 동작 | 설명 |
| --- | --- | --- |
| 서버가 꺼져 있음 | `connectTimeout` 발생 | 서버에 연결 자체 불가 |
| 서버 연결 OK, 응답이 너무 느림 | `readTimeout` or `socketTimeout` | 응답이 지연되어 시간 초과 |
| 업로드 파일이 너무 큼 | `writeTimeout` (OkHttp만) | 요청을 전송하는 데 시간이 너무 오래 걸림 |

<br>

**✅ 마무리 요약**
| 타임아웃 종류 | Apache HttpClient 설정 | OkHttp 설정 |
| --- | --- | --- |
| 연결 타임아웃 | `connectTimeout` | `connectTimeout` |
| 읽기 타임아웃 | `socketTimeout` | `readTimeout` |
| 쓰기 타임아웃 | 없음 (자동 처리) | `writeTimeout` |
> 둘 다 실무에서 널리 사용되며, 타임아웃을 명확히 설정해 두면 예외 상황에서 서비스가 멈추지 않고 안정적으로 대응할 수 있습니다.<br>
특히 외부 API 호출 시 타임아웃 설정은 필수입니다.

<br>

## 재시도
### 재시도 가능

<br>

### 재시도 횟수와 간격

<br>

### 재시도 폭풍(retry storm) 안티패턴

<br>

## 동시 요청 제한

<br>

## 서킷 브레이커
- 빠른 실패는 장애가 발생한 기능에 부하가 더해지는 것을 방지할 뿐 아니라, 불필요한 자원 낭비를 줄여 전체 서비스의 안정을 유지하는 데도 도움이 된다. **(103)**

<br>

빠른 실패(Fail Fast)가 불필요한 자원 낭비를 줄이는 이유는 다음과 같은 논리적인 흐름으로 설명할 수 있습니다:

<br>

**✅ 핵심 개념: 빠른 실패란?**
- 오류나 실패가 감지되면 가능한 한 빨리 요청을 중단하고 예외를 발생시켜 처리를 멈추는 전략입니다.
- 대표적인 예: 타임아웃, 서킷 브레이커, 유효성 검증, 즉시 예외 처리 등

<br>

**✅ 빠른 실패가 자원 낭비를 줄이는 이유**
1. 한정된 자원(스레드, 커넥션, 메모리 등)의 점유 시간을 줄여줌
    - 요청이 무의미하게 오래 걸리면 해당 요청을 처리하는 스레드, DB 커넥션, 네트워크 자원이 길게 점유됩니다.
    - 빠르게 실패하면 → 그 자원을 더 빨리 회수 → 다른 요청에 재사용 가능

<br>

📌 예시:
> 응답이 안 오는 외부 API에 30초씩 대기하면, 그동안 스레드가 묶여 있음.<br>
하지만 1초 내 타임아웃으로 빠르게 실패하면 나머지 29초 동안 스레드를 다른 작업에 쓸 수 있음.

<br>

2. 무의미한 재시도나 뻗은 서비스 호출을 방지
    - 실패한 기능에 계속 요청을 보내는 건 부하만 가중시킴 (악순환)
    - 빠르게 실패하면 → 해당 기능은 일시적으로 사용하지 않음 → 부하 차단 + 안정화 시간 확보

<br>

📌 예시:
> DB가 뻗었는데 계속 트랜잭션 열고 커넥션 요청하면, 남아 있는 리소스까지 고갈 → 전체 시스템 마비 가능

<br>

3. 비즈니스 로직 처리 단계를 줄여 CPU/메모리 낭비 방지
- 유효성 검증 같은 기본 검사를 초반에 바로 실패시킴으로써, 이후 처리 로직 (서비스, DAO, API 호출 등)으로 넘어가지 않음
- 즉, "어차피 실패할 요청이면 처음부터 짧게 끊어라"는 전략

<br>

📌 예시:
> 로그인 시 비밀번호가 비었으면 DB 조회까지 가지 말고 애초에 막아야 효율적

<br>

**✅ 정리하면**
> 빠른 실패는 요청을 짧게 끝내고, 불필요한 처리 과정을 생략하며, 유한한 시스템 자원을 낭비하지 않게 함으로써 전체 시스템의 안정성과 효율성을 높여줍니다.

<br>

**✅ 비유적으로 이해하자면:**
> 고장 난 자동판매기에 계속 동전을 넣는다면,<br>
동전 낭비 + 줄도 길어지고 + 다른 사람들도 피해를 봄.<br>
반면 "이 기계 고장났음"이라고 바로 실패 신호를 주면<br>
낭비를 막고, 사람들은 다른 기계로 이동할 수 있음.<br>
이게 빠른 실패의 개념입니다. ✅

<br>

## 외부 연동과 DB 연동
### 외부 연동과 트랜잭션 처리

<br>

### 외부 연동이 느려질 때 DB 커넥션 풀 문제
- DB 연동과 무관하게 외부 연동을 실행할 수 있다면, DB 커넥션을 사용하기 전이나 후에 외부 연동을 시도하는 방안도 고려해볼 수 있다. 이 경우에는 실패한 외부 연동에 대한 후처리를 반드시 고민해야 한다. 후처리 방법으로는 트랜잭션으로 반영된 데이터를 되돌리는 보상 트랜잭션을 사용하는 방법 또는 기능 특성에 따라 데이터를 후보정하는 방법 등이 있다. **(108)**

<br>

외부 시스템 연동 중 실패 발생 시, 어떻게 시스템의 일관성과 안정성을 유지할 수 있을지에 관한 것입니다.<br>
여기서 말하는 후처리 방법은 크게 다음 두 가지로 나눌 수 있습니다:

<br>

**✅ 1. 보상 트랜잭션 (Compensating Transaction)**<br>
✔ 개념:
- 이미 커밋된 트랜잭션을 되돌릴 수 없을 때, 그 효과를 상쇄하는 반대 작업을 별도로 실행하는 방식입니다.
- 즉, "롤백은 못하지만 되돌리는 작업은 별도로 수행한다"는 개념입니다.

<br>

✔ 언제 쓰나?
- DB 트랜잭션은 성공했지만, 그 후 외부 API 호출 실패
- 또는 분산 트랜잭션이 어려운 환경 (ex: 다른 시스템 간 연동)에서 자주 사용

<br>

✔ 예시:
```
1. 주문 데이터 저장 (DB 트랜잭션 커밋됨)
2. 결제 시스템 연동 실패
3. 보상 트랜잭션: 주문 상태를 "실패"로 변경 + 환불 처리 예약
```

<br>

✔ 특징:
- 비동기 메시지나 스케줄러, 보상 큐 등을 사용해 나중에라도 처리 가능
- 일관성은 유지하지만 실시간성과는 다를 수 있음

<br>

**✅ 2. 데이터 후보정 (Manual/Post Correction)**<br>
✔ 개념:
- 실패 상황이 발생해도 DB 트랜잭션은 그대로 유지하고,
- 나중에 관리자 또는 자동화된 후속 처리 로직을 통해 데이터를 정합성 있게 보정하는 방법

<br>

✔ 언제 쓰나?
- 외부 연동 실패가 서비스 전체에 치명적인 영향은 없는 경우
- 기능적으로 후처리만으로 문제가 해결되는 경우

<br>

✔ 예시:
```1. 회원 가입 완료 (DB 저장 완료)
2. 외부 마일리지 적립 API 실패
3. 별도 적립 실패 로그 저장
4. 후속 배치/스케줄러가 실패 로그를 읽고 마일리지 적립 재시도
```

<br>

✔ 특징:
- 회복 지연 가능성 있음 (재시도, 보정 시점이 지연될 수 있음)
- 비즈니스에 따라 수동 처리 화면(UI)이나 관리자 기능 필요

<br>

**✅ 그 외 보조 전략**
| 전략 | 설명 |
| --- | --- |
| Retry (재시도) | 일시적 오류라면 일정 횟수 자동 재시도 (하지만 무한 재시도는 금지!) |
| Dead-letter Queue (DLQ) | 실패한 요청을 별도 큐로 보내서 나중에 수동 처리 또는 보상 처리 |
| Alert + 수동 대응 | 외부 시스템 장애 시 알람 발생 후 관리자 조치 (보정 기능 필요) |

<br>

**✅ 후처리를 고려해야 하는 이유**
> DB 작업이 완료된 이후 외부 연동이 실패하면 시스템은 '성공'으로 간주하지만, 실제로는 비즈니스적으로 실패한 상태가 됩니다.<br>
이 때 후처리를 고민하지 않으면, 사용자에게는 성공처럼 보이지만 실제 기능이 제대로 동작하지 않은 상황이 발생하게 됩니다.

<br>

**✅ 정리 요약**
| 방법 | 개념 | 장점 | 단점 |
| --- | --- | --- | --- |
| 보상 트랜잭션 | 반대 동작으로 효과 무효화 | 데이터 정합성 유지 | 구현 복잡도 높음 |
| 후보정 | 사후 처리로 데이터 정리 | 구현 유연성 높음 | 일관성 확보까지 지연 가능 |
| 재시도/큐 | 일시적 오류 대응 | 자동 복구 가능 | 재시도 한계 설정 필요 |

<br>

필요하다면 어떤 후처리 전략이 적합한지는 기능의 중요성, 실시간성 요구 수준, 외부 시스템 특성에 따라 선택해야 합니다.

<br>

## HTTP 커넥션 풀
- HTTP/1.1에서는 서버가 Keep-Alive 헤더로 연결 유지 시간을 지정한다. 이 시간이 지나면 서버는 연결을 끊기 때문에, 클라이언트의 커넥션 풀도 이 값보다 더 오래 커넥션을 유지하면 안 된다. **(110)**

<br>

HTTP Keep-Alive와 클라이언트 커넥션 풀은 관련이 있지만, 역할과 관점이 다릅니다.<br>
아래에서 개념과 차이를 정리해드릴게요.

<br>

**✅ 용어 정리 먼저**
| 개념 | 설명 |
| --- | --- |
| Keep-Alive | HTTP/1.1에서 한 번 연결한 TCP 커넥션을 재사용할 수 있도록 유지하게 하는 기능 |
| 클라이언트 커넥션 풀 | 클라이언트(예: Java의 HttpClient, OkHttp 등)가 미리 생성하거나 재사용하는 TCP 커넥션들을 관리하는 풀(pool) |

<br>

**✅ HTTP Keep-Alive는 서버의 약속**
- 서버는 응답 헤더에 `Connection: keep-alive`와 함께 `Keep-Alive: timeout=5` 같은 값을 보냅니다.
- 이는 **"이 연결을 최대 5초 동안 유휴 상태로 유지할게요. 그 후엔 닫습니다"**라는 의미입니다.
```http
HTTP/1.1 200 OK
Connection: keep-alive
Keep-Alive: timeout=5, max=100
```

<br>

**✅ 클라이언트 커넥션 풀은 클라이언트의 전략**
- 클라이언트는 HTTP 요청을 보낼 때마다 새로운 TCP 연결을 만들지 않고, 기존 연결을 재사용하기 위해 커넥션 풀을 운영합니다.
- 이 풀에는 Keep-Alive된 연결들이 들어 있고, 다시 쓰려고 기다립니다.

<br>

**✅ 차이점 요약**
| 구분 | 서버 Keep-Alive | 클라이언트 커넥션 풀 |
| --- | --- | --- |
| 주체 | 서버 | 클라이언트 (예: HttpClient) |
| 역할 | 커넥션을 얼마까지 유지할지 서버가 클라이언트에게 알려줌 | 클라이언트가 커넥션을 재사용하기 위해 풀에서 관리 |
| 의미 | "이 커넥션은 최대 X초까지만 유효해" | "유효한 커넥션이면 재사용하자" |
| 문제 | 서버가 먼저 연결을 끊으면, 클라이언트가 모르면 오류 발생 가능 | 클라이언트가 끊긴 커넥션을 재사용하려 하면 예외 발생 |

<br>

**✅ 왜 차이가 중요한가?**<br>
클라이언트가 서버보다 오래 커넥션을 유지하고 재사용하려 하면 문제 발생 가능!

<br>

❌ 예시 상황:<br>
1. 서버가 Keep-Alive 5초 설정함
2. 클라이언트 커넥션 풀에서 10초 동안 커넥션 유지함
3. 6초 후 커넥션 재사용 시도 → 서버는 이미 연결 종료 → SocketException, EOFException 발생

<br>

**✅ 해결 방안**
- 클라이언트가 서버의 Keep-Alive 값을 정확히 인지하지는 못함
- 그래서 커넥션 풀에 MaxIdleTime 설정을 할 때, 보수적으로 잡는 게 일반적입니다
    - 예: 서버가 10초 유지하면, 클라이언트는 8초로 설정
- 또는 커넥션 재사용 전에 테스트 요청(또는 ping)을 보내 유효성 확인

<br>

**✅ 정리**
- Keep-Alive: 서버 → 클라이언트에게 연결 유지 시간을 알려주는 정보
- 커넥션 풀: 클라이언트 → 연결을 재사용하고 관리하기 위한 저장소
- 둘은 연결을 얼마나 유지할 수 있는지에 대한 기준과 전략이 다르며, 이 차이를 잘 조율하지 않으면 끊긴 커넥션을 재사용하려다 오류가 발생할 수 있습니다.

<br>

**✅ HTTP 연결의 기본 동작**
| 구분 | HTTP/1.0 | HTTP/1.1 |
| --- | --- | --- |
| 기본 연결 | 요청-응답 후 연결 끊음 | 기본적으로 Keep-Alive (연결 유지) |
| 명시 필요 | `Connection: keep-alive` 필요 | 생략 가능, 자동 Keep-Alive |
| 끊을 때 | `Connection: close`로 명시 가능 | 서버 또는 클라이언트가 타임아웃 후 끊음 |

<br>

**✅ 서버와 클라이언트의 역할 비교**
| 항목 | 서버 (`Keep-Alive`) | 클라이언트 (`커넥션 풀`) |
| --- | --- | --- |
| 연결 유지 의사 통지 | 응답 헤더에 Keep-Alive 관련 정보 포함 (`timeout`, `max`) | 별도 통지 없음. 연결 재사용 여부는 클라이언트 내부 전략 |
| 실제 연결 끊는 쪽 | 보통 서버가 끊음 (Keep-Alive timeout 경과 시) | 클라이언트도 일정 시간 후 커넥션 풀에서 제거 가능 |
| 누가 연결을 유지하나? | 서버: 일정 시간 동안 연결 열어둠 | 클라이언트: 커넥션 풀에 보관해두고 재사용 시도 |
| 커넥션 재사용 주체 | 재사용 안 함 (HTTP는 요청마다 새 응답) | 재사용함 (풀에서 꺼내 다시 요청) |

<br>

**✅ 정확한 정리**
> ✔ Keep-Alive는 서버가 "연결을 당장 닫지 않을게요"라고 약속하는 것<br>
✔ 커넥션 풀은 클라이언트가 그 약속된 연결을 일정 시간 재사용하려고 보관하는 것<br>
✔ 서버가 Keep-Alive timeout이 지나면 연결을 끊을 수 있고,<br>
✔ 클라이언트도 커넥션 풀에서 오래된 커넥션을 제거하거나 유효성 검사를 통해 끊을 수 있음

<br>

즉:
- 서버는 연결을 유지하거나 끊는 쪽이고,
- 클라이언트는 유지된 연결을 풀에 보관하고, 다시 쓰거나 버리는 쪽입니다.

<br>

**✅ 예시로 이해하기**
```
클라이언트: 요청 보냄
↓
서버: 응답 + "Keep-Alive: timeout=5"
↓
클라이언트: 응답 받은 연결을 커넥션 풀에 저장
↓
(3초 뒤)
클라이언트: 같은 서버에 재요청 → 커넥션 풀에서 꺼내 재사용
↓
(6초 뒤)
클라이언트: 또 요청 시도 → 서버가 이미 커넥션 끊음 → 오류 발생
```
그래서 클라이언트는 서버의 Keep-Alive 시간보다 더 짧게 커넥션 풀 보관 시간을 설정하거나, 재사용 전에 연결이 살아있는지 검사해야 합니다.

<br>

### 연동 서비스 이중화
