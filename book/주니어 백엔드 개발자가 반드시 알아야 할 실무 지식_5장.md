# 5장 비동기 연동, 언제 어떻게 써야 할까
## 동기 연동과 비동기 연동

<br>

## 별도 스레드로 실행하기
- **(122)**
```java
// 비동기로 실행되는 메서드임을 명시함!!!!!!
@Async
public void sendPushAsync(PushData pushData) {
    try {
        // 푸시 클라이언트를 통해 푸시 전송 시도!!!!!!
        pushClient.sendPush(pushData);
    } catch (Exception e) {
        // 첫 번째 전송 시도 실패 시 재시도 전 대기 시간!!!!!
        try {
            Thread.sleep(500);  // 0.5초 대기!!!!!!
        } catch (Exception ex) {
            // 슬립 중 예외 발생 시 아무것도 하지 않음 (무시)!!!!
        }

        try {
            // 다시 한 번 푸시 전송을 시도!!!!!!!!
            pushClient.sendPush(pushData);
        } catch (Exception e1) {
            // 재시도마저 실패했다면???
            // 로그로 남기거나 추후 조치를 취할 수 있도록 해야 함!!!!!!!
            // ex) log.error("Push 실패", e1); 처럼 로그 기록 가능!!!!!!!!
        }
    }
}
```

<br>

- **(123)**

<br>

당연히!!!!! 코드를 실행할 때는 PC(혹은 서버)의 스레드랑 메모리가 무조건 필요합니다요!!!!!!!! ⚡⚡⚡

**✅ 코드 실행 시 PC의 스레드 & 메모리가 필요한 이유**<br>
**🔸 1. 스레드(Thread)**
- 코드가 실행된다는 건 결국 CPU가 명령을 처리한다는 뜻이죠!!!!!!
- 이때 CPU에게 명령을 전달하고 실행하는 단위가 바로 스레드예요!!!!!!!!
- 자바에서 `main()` 메서드가 실행된다? 👉 이건 메인 스레드가 생성돼서 코드 실행 시작한 거예요!!!!
- `@Async`, `Thread`, `ExecutorService`로 만든 애들? 👉 전부 다 운영체제가 스레드를 만들어서 실행함!!!!!

**🔸 2. 메모리(Memory, RAM)**
- 변수, 객체, 배열, 클래스 인스턴스 등등 전부 메모리 위에 올라가야 사용 가능해요!!!!
- 자바 기준으로도:
    - `Heap`: 객체 저장
    - `Stack`: 메서드 호출, 지역 변수 저장
    - `Method Area`: 클래스, static 데이터
- 이 모든 게 PC의 실제 RAM을 사용해서 구성됩니다!!!!!

<br>

💥 예를 들어서 💥
```java
public static void main(String[] args) {
    String name = "헴";
    System.out.println("안녕!! " + name);
}
```
🔧 이 코드가 실행되면?
- 운영체제(OS)가 main 스레드 하나 생성 👉 CPU에서 실행!!!!
- `"헴"`이라는 문자열, `"안녕!!"` 결과값은 전부 메모리에 올라감(RAM 사용)

<br>

**💣 결론 💣**
> ✅ 코드 실행 = 스레드 + 메모리 없이는 불가능한 일이다!!!!!!!!!!<br>
✅ 비동기, 병렬 처리, 객체 생성, 연산 처리 전부!!! 피시의 리소스를 쓰는 거다!!!!!!!!!

<br>

## 메시징
- **(126)**

<br>

**✅ 1.**
> `메모리에만 메시지를 보관하는 큐 설정을 사용하면 장애 상황 시 메시지가 유실될 수 있다.`<br>
→ 메모리는 피시를 껐다가 켜면 날라가는 휘발성이기 때문이야?

<br>

🧠 정확합니다 헴!!!!!!
- RAM(메모리)은 전원이 꺼지면 데이터가 싹 다 날아가는 휘발성 저장소예요!!!!
- 그래서 메모리 기반 큐는 장애(서버 죽음, 전원 꺼짐) 발생 시, 큐에 있던 메시지가 영영 증발해버릴 수 있음!!!!!

> → 큐 설정을 사용하지 않을 수도 있어? 그러면 메모리에 메시지를 보관 안 해?? 그러면 어디에 해???

<br>

💥 좋은 질문이십니다!!!!!!<br>
RabbitMQ 같은 MQ는 디스크에도 메시지를 저장할 수 있어요!!!!<br>
📦 큐 설정에 따라 이렇게 구분됩니다:
- 메모리 큐: 속도 빠름💨, 대신 장애 시 메시지 유실 위험 ⚠️
- 퍼시스턴트 큐(지속성 큐): 디스크에도 메시지 저장 🧱 → 서버 죽어도 복구 가능 💪<br>
🔧 큐 설정 예시 (RabbitMQ 기준):
```bash
durable=true      # 큐가 재시작에도 살아남음
deliveryMode=2    # 메시지도 디스크에 저장
```

<br>

**✅ 2.**
> 소비자의 성능이 느려지면 큐에 과부하가 걸리는 이유는?

<br>

헴!!!!! 이건 RabbitMQ의 푸시 모델(push model) 특성 때문이옵니다!!!!!<br>
📌 설명 드리자면:
- RabbitMQ는 생산자가 보낸 메시지를 바로 소비자에게 푸시합니다.
- 그런데 소비자가 느리면???
    - 메시지를 빨리 못 소비함 ❌
    - 안 먹은 메시지는 계속 큐에 쌓임 📥📥📥
    - 큐가 계속 커짐 → 메모리 고갈, 디스크 증가, 처리 지연 발생!!! 🧨💣
    - 이걸 백프레셔(Back Pressure) 현상이라 불러요!!!
> 💡 즉, 소비자가 느리면 큐가 과부하되고, 전체 시스템 성능이 저하됨!!!!

<br>

🛠 해결책으로는:
- Pull 방식으로 전환하거나
- Prefetch 설정 조절 (한 소비자가 받을 메시지 수 제한)
- 컨슈머 스케일아웃 (소비자를 여러 개 둬서 분산 처리)

<br>

✅ 질문 요약
> 소비자가 느리면 RabbitMQ가 메시지를 푸시하지 못해서 큐에 쌓이는 거야?<br>
즉, RabbitMQ는 소비자 성능을 보고 푸시를 결정하는 거야?

<br>

💥 정답: 맞습니다! 소비자가 느리면 푸시가 지연되고 큐에 메시지가 계속 쌓입니다!!! 💥<br>
RabbitMQ는 단순히 막무가내로 메시지를 던지지 않아요!!!<br>
"컨슈머가 처리할 준비가 되었을 때" 메시지를 푸시합니다!!!<br>
🔧 그럼 어떻게 판단하냐???<br>
RabbitMQ는 QoS(Consumer Quality of Service) 기능 중 하나인<br>
basic.qos에서 prefetch count 값을 기반으로 푸시를 조절합니다!!!!<br>
예시:
```java
channel.basicQos(10);
```
🔁 이 설정은?<br>
- 한 소비자에게 최대 10개 메시지를 보내고,
- 이 10개를 확인(ack) 받기 전까지는 더 이상 메시지를 푸시 안 함!!!!!!!!!

<br>

💣 그래서 소비자가 느리면???
1. RabbitMQ가 메시지를 푸시함 ➝ 소비자 못 처리함
2. ack가 안 옴 ➝ 더 이상 푸시 안 됨
3. 대신 큐에 메시지가 계속 쌓임 📦📦📦
4. 결국 → 큐가 터짐, 메모리 부족, 성능 저하, 시스템 병목 발생!!!!!! 💥🔥

<br>

🔁 요약
| 상황 | RabbitMQ 동작 | 결과 |
| --- | --- | --- |
| 소비자 빠름 | 푸시 → ack → 푸시 계속됨 | 정상 |
| 소비자 느림 | 푸시 → ack 안 옴 → 푸시 정지 | 큐에 계속 쌓임 |
| 소비자 없음 | 대기만 함 (큐에 계속 적재) | 위험 |

<br>

🧠 한줄 핵심 정리!!!!!
> ✅ RabbitMQ는 소비자 성능에 맞춰서 메시지를 푸시한다!!!!<br>
✅ 느린 소비자는 ack가 늦어지고, 그만큼 큐에 메시지가 계속 쌓이게 된다!!!!!

<br>

**✅ 3.**
> 레디스 pub/sub는 메모리를 사용하는데 왜 래빗MQ보다 처리량이 더 높아???

<br>

💣 여기도 핵심을 찔러버리셨습니다!!!!!!!!!<br>
🥊 이유는 구조 차이 때문입니다!!!!!
| 항목 | Redis pub/sub | RabbitMQ |
| --- | --- | --- |
| 메시지 저장 | X (영구 저장 없음) | O (큐에 저장 가능) |
| 라우팅/보장 | 단순 pub/sub | 복잡한 라우팅 + QoS + 보장 처리 |
| 프로토콜 | TCP 단순 송수신 | AMQP 기반 복잡한 프로토콜 |
| 지연/성능 | 극단적으로 빠름 (단방향) | 안정성 중시 (조금 느림) |
| 메시지 유실 시 | 유실됨 (구독자 없으면 버림) | 디스크/큐로 보장 가능 |

<br>

👉 즉, 레디스 pub/sub는 가벼운 구조라서 처리량이 미쳤을 정도로 빠름!!!!!!!!<br>
하지만!!! 보장 기능이 없기 때문에 신뢰성이 떨어짐!!!!!!<br>
📌 정리:
- Redis pub/sub 👉 초고속, 신뢰성 낮음, 실시간 알림 등에 굿!!!
- RabbitMQ 👉 느리지만 안정성 높음, 복잡한 메시지 처리에 굿!!!

<br>

**💥 진짜 실무 한줄 정리 💥**
> ✅ 휘발성 때문에 메모리 기반 큐는 유실 위험이 있고,<br>
✅ 소비자 느리면 큐가 밀려서 백프레셔 생기고,<br>
✅ Redis pub/sub는 단순해서 빠르지만 신뢰성은 약하다!!!!!!!!!!

<br>

### 메시지 생성 측 고려 사항
- **(127)**

<br>

💥 먼저 문장 다시 보면?
> "로그인 실패 메시지 전달에 실패하면 로그인 차단 기능은 동작하지 않게 된다.<br>
하지만 나머지 다른 기능은 정상 동작하므로 치명적인 오류는 아니다."

<br>

이게 뭔 뜻이냐!!!<br>
"로그인 실패 횟수를 기록하는 메시지를 못 보냈다" → "차단 기능 작동 안 함"<br>
그렇지만!!!<br>
"로그인 기능 자체는 정상 작동"이라는 말이오!!!!!!!!!

**✅ 그 이유는?!**<br>
1. 로그인 기능과 실패 기록 기능이 분리되어 있기 때문!!!
- 로그인은 인증 서버의 주 로직 → ID/PW 체크, 세션 발급 등!!!
- 반면, 로그인 실패 횟수 저장은 주로 다음과 같이 부가 기능으로 동작함:
    - 메시지 큐(RabbitMQ, Kafka, Redis pub/sub 등)에 실패 이벤트 전달
    - 비동기 consumer가 이걸 DB나 Redis에 기록
    - 일정 횟수 초과 시 차단 처리

<br>

👉 근데 만약 메시지를 전달 못했다?
- 실패 횟수 안 올라감 ❌
- 차단 기준 못 채움 ❌
- 결과적으로 차단이 안 됨!

<br>

그러나!!!
- 로그인 시도 자체는 여전히 진행됨
- 세션 발급도 되고, 사용자에게는 "로그인 실패" 메시지도 보임
- 따라서 시스템 전체가 멈추진 않음 👉 "치명적인 오류는 아님"

<br>

2. 비동기 구조라서 영향이 제한적임
- 로그인 실패 메시지 전송은 보통 비동기 처리됨 (`@Async`, MQ 등)
- 실패해도 주 로직(로그인 인증)에는 영향 없음
- 즉, 메시지 전송 실패 = 로그인 보안 기능 일부가 무력화된 상태일 뿐,<br>
로그인 자체가 안 되는 건 아님!!!

<br>

**⚠️ 그래서 왜 "치명적인 오류는 아니다"?**
- 사용자 로그인은 정상 작동함 → 서비스 전체 장애는 아님
- 하지만 장기적으로는 보안 리스크 있음!!! 😱<br>
(ex. 공격자가 계속 틀려도 차단 안 됨)

**🧠 요약 한방 정리!!!!!**
| 항목 | 설명 |
| --- | --- |
| 로그인 실패 메시지 역할 | 실패 횟수 기록 → 일정 횟수 넘으면 로그인 차단 |
| 실패 시 영향 | 차단 기능 동작 안 함 ❌, 로그인 로직은 정상 ⭕ |
| 시스템 전체 영향 | 없음 (비동기 + 핵심 로직과 분리) |
| 치명성 판단 | 보안 측면에서 "잠재적 위험", 전체 시스템은 "치명적 아님" |

<br>

- **(129)**

<br>

**✅ 글로벌 트랜잭션이란?**
> 여러 개의 자원(DB, 메시징 시스템 등)에서 일어나는 여러 개의 트랜잭션을 하나로 묶어<br>
모두 성공하거나, 모두 실패하도록 보장하는 트랜잭션 처리 방식!!!

<br>

📦 예를 들어:
- A 서비스: 주문 정보를 DB A에 저장 (트랜잭션 1)
- B 서비스: 결제 정보를 DB B에 저장 (트랜잭션 2)

<br>

이걸 하나의 트랜잭션처럼 처리하고 싶을 때 → 글로벌 트랜잭션!!!!!<br>
💥 그럼 어떻게 모든 DB/자원을 하나처럼 묶어 처리하냐???<br>
2단계 커밋(Two-Phase Commit, 2PC) 💣💣💣<br>
**✅ 2단계 커밋 (2PC) 구조**
| 단계 | 설명 |
| --- | --- |
| 1단계: 준비(Prepare) | 모든 자원(DB, 메시지 시스템 등)에 “커밋 준비됐냐?” 하고 물어봄 |
| 2단계: 커밋(Commit) | 모든 자원이 “준비됐어요!” 라고 응답하면 → 실제로 커밋 진행 |
| ❌ 한 군데라도 실패? | → 전체 롤백!!! (모두 되거나, 모두 안 되거나!!) |

<br>

예시 흐름:
1. 트랜잭션 매니저가 DB A, DB B, 메시징 시스템에게 “준비됐냐?” (prepare)
2. 모두 OK → 각 자원에 “커밋해라” (commit) 명령
3. 만약 누가 "난 준비 안 됨" → “다 롤백해라!” (rollback) 명령

<br>

이게 바로 진짜 “모 아니면 도” 방식!!!!!!!!!<br>
**✅ 장점**
- 💯 정합성 보장: 메시지 보내다 실패하면 DB도 롤백됨!
- 💣 모두 성공 or 모두 실패 → 중간 상태 없음!!!!!

<br>

**❌ 단점**
- 성능 저하 심함 😵<br>
왜냐? 준비 → 대기 → 커밋까지 2단계 거치느라 처리 속도 느림<br>
→ 트랜잭션 유지 시간 길어짐 → 동시 처리량 떨어짐
- 메시지 시스템이 2PC를 지원해야 가능함<br>
(Kafka ❌, Redis ❌, RabbitMQ ❌ → 대부분 지원 안 함!!!)

<br>

**💡 그래서 요즘은?**<br>
요즘 실무에서는 글로벌 트랜잭션 대신<br>
“최종 일관성(Eventual Consistency)” + “사후 보정 방식” (ex. Saga 패턴) 많이 씁니다!!!!!

<br>

**🧠 헴을 위한 요약!!!**
| 항목 | 설명 |
| --- | --- |
| 글로벌 트랜잭션 | 여러 자원을 하나의 트랜잭션처럼 처리 (성공/실패 함께) |
| 2PC (Two-Phase Commit) | 준비 단계 + 커밋 단계로 나눠서 안정성 보장 |
| 장점 | 데이터 정합성 완벽 보장 |
| 단점 | 성능 저하, 처리량 감소, 대부분 MQ와는 호환 ❌ |

<br>

헴!!!!!!!!!! 이건 진짜 시스템 설계할 때 “데이터가 꼬이면 안 돼!”를 보장하는 무기지만,<br>
너무 느려서 실무에서는 잘 안 씁니다요!!!<br>
대신, 비동기 이벤트 + 로그 기반 보정 처리가 대세!!!!!!!

<br>

### 메시지 소비 측 고려 사항
- **(130)**

<br>

**✅ 1. "메시지를 메모리 집합(Set)으로 관리" → 어떻게??**<br>
🔹 무슨 말이냐?<br>
메시지 중복 방지를 위해, "이 메시지는 처리했는가?" 를 기록하는 방식 중 하나예요.<br>
📌 Set은 중복 허용 X → 메시지 ID를 Set에 넣어두고, 이미 존재하면 처리 안 하면 됨!!!!!

<br>

**🔨 실전 예시 (Java 기준)**
```java
Set<String> processedMessageIds = ConcurrentHashMap.newKeySet();

public void handleMessage(Message message) {
    String msgId = message.getId();

    if (processedMessageIds.contains(msgId)) {
        return; // 이미 처리된 메시지니까 무시!!
    }

    // 메시지 처리 로직
    process(message);

    // 처리 완료 후 ID 저장
    processedMessageIds.add(msgId);
}
```

<br>

**💡 대신 주의할 점!**
- 이건 서버 꺼지면 날아감 👉 휘발성 ❌
- 그래서 Redis Set 같은 외부 캐시 메모리도 많이 씀!
```bash
SISMEMBER processed_messages {msgId}  # 처리 여부 확인
SADD processed_messages {msgId}       # 처리 완료 후 기록
```

<br>

- **(131)**

<br>

**✅ 2. "읽기 타임아웃이 났는데 성공했을 수 있다" → 왜????**<br>
헴!!!!!!!! 이건 네트워크 프로그래밍의 함정 중의 함정입니다요!!!!!! ⚠️<br>
**🔹 무슨 상황?**
1. 외부 API에 POST 요청을 보냄 (ex. 주문 생성)
2. 응답을 기다림... 근데 일정 시간 지나도 응답이 안 옴 → 타임아웃
3. 그래서 개발자는 “실패했다”고 판단 😓

<br>

하지만!!!!!!!!!<br>
💥💥 실은 서버 쪽에서는 요청을 받아서 이미 처리하고 있었던 것임!!!

<br>

**🔥 왜 이런 일이 생기냐?**
- 타임아웃은 응답을 못 받은 것이지, 요청 자체가 실패한 건 아님!!!!
- 예를 들어,
    - 클라이언트 → 서버 요청 전송 완료
    - 서버 → 정상 처리 완료
    - 응답이 네트워크 장애 등으로 클라이언트에 도달 못함 → timeout 발생

<br>

📦 즉, 서버 입장에선 “처리 완료”지만<br>
클라이언트 입장에선 “어? 응답 못 받았는데?? 실패 아님??” 되는 상황!!!!

<br>

**🤯 이게 왜 위험하냐?**
- 클라이언트가 “실패했다”고 판단해서 같은 요청을 다시 보냄 (retry)
- 서버는 이미 처리한 상태에서 다시 요청을 받아 → 중복 처리됨!!!!!!! 💣💣

<br>

**💡 그래서 실무에서는?**
- 메시지 ID, 요청 ID 같은 걸 idempotent하게 처리
- 서버는 같은 요청이면 "이미 처리됐어요"라고 응답해야 함!!!!

<br>

**🧠 헴을 위한 실전 요약!!!!!**
| 상황 | 설명 |
| --- | --- |
| 메모리 집합으로 관리 | `Set`이나 `Redis`를 써서 메시지 ID로 중복 체크 |
| 타임아웃 발생해도 성공 가능 | 응답 못 받았을 뿐, 서버는 요청을 이미 처리했을 수 있음!!! |
| 해결 방법 | 메시지 중복 방지(ID 저장), idempotent 설계, 외부 API retry 설계에 주의!!! |

<br>

### 메시지 종류: 이벤트와 커맨드
- **(132)**

<br>

이벤트 기반 아키텍처(Event-Driven Architecture)의 진수!!!!!!!! 💥🔥<br>
“발생한 사건에 관심 있는 소비자가 메시지를 수신한다” — 이게 바로 실시간 확장성과 유연함을 가능하게 해주는 핵심 개념입니다요!!!!!! 👊👊👊<br>
**✅ 이 문장의 의미를 풀어보면?**
> “발생한 사건에 관심이 있는 소비자가 메시지를 수신하는 방식이다”

<br>

즉!!!!!!!!!!<br>
누가 강제로 지목한 게 아니라,<br>
"어떤 일이 발생했을 때 그 일에 관심 있는 놈들만 알아서 반응한다"는 거예요!!!!!<br>
**💣 예시: "배송 완료" 이벤트**
1. 누가 메시지를 발행?
    - 🛒 주문 시스템에서 "배송 완료" 이벤트 메시지 발행
2. 누가 이걸 수신함?
    - 📲 문자 발송 서비스 (고객에게 문자 보내기 위해!)
    - 🧾 포인트 적립 서비스 (배송 완료 시 포인트 지급!)
    - 📊 통계 서비스 (배송 통계 집계용!)
    - 🤖 챗봇 서비스 (고객에게 배송 완료 알림 전송용!)

<br>

👉 즉, "배송 완료"라는 사건에 관심 있는 소비자들이 알아서 이 메시지를 구독해서 처리함!!!!

<br>

**✅ 이벤트 메시지의 핵심 특징**
| 항목 | 설명 |
| --- | --- |
| 정해진 수신자 없음 | 발행자는 "그냥 발생 사실만 알림" |
| 구독자만 수신 | 이 사건에 관심 있는 서비스만 메시지를 받아감 |
| 처리 방식 자유로움 | 받는 쪽이 처리할지 말지 결정함 (ex. 문자 보낼지 말지) |
| 확장성 뛰어남 | 새로운 구독자 추가해도 발행자는 코드 안 바뀜!!!!!!!!!! 🔥🔥🔥|

<br>

**📦 메시지 구조 비교 (명령 vs 이벤트)**
| 명령 메시지 | 이벤트 메시지 |
| --- | --- |
| "문자 보내!" | "배송 완료됨!" |
| 발신자가 행동 지시 | 발신자가 사건만 알림 |
| 소비자는 시킨 일만 함 | 소비자는 알아서 판단함 |

<br>

**💡 왜 이게 좋은가?**
- 의존성 약함 (Loosely Coupled) 👉 서비스 간 결합도 낮아짐!
- 유연성 + 확장성 최고 👉 새 서비스 붙이기 쉬움!
- 재사용성 굿 👉 하나의 이벤트로 여러 기능 확장 가능!

<br>

**🧠 한 줄 요약!!!**
> ✅ "이벤트 기반 메시지는, ‘누가 시켜서’가 아니라 ‘내가 관심 있어서’ 받아서 처리하는 구조다!!!!"<br>
✅ "발행자는 단지 사건을 알릴 뿐, 수신자는 자율적으로 행동한다!!!!"

<br>

“관심 있는 놈들만 알아서 반응한다”는 그놈(?)들이 바로바로 이벤트의 구독자(Subscriber) 입니다요!!!!!!! 📬👂🔥<br>
즉, “이벤트 구독자” = 어떤 사건(Event)에 관심 있어서 해당 메시지를 수신하고 반응하는 서비스를 말하는 겁니다!!!!<br>
**✅ 이벤트 구독자는 어떻게 "구독"하냐??**<br>
구독 방법은 사용하는 **메시징 시스템(Redis Pub/Sub, Kafka, RabbitMQ 등)**에 따라 조금씩 다르지만, 기본 개념은 같아요:<br>
**🔸 1. Redis Pub/Sub 에서의 구독**
```java
// Java에서 Redis Pub/Sub 구독 예시
redisTemplate.getConnectionFactory()
    .getConnection()
    .subscribe((message, pattern) -> {
        String event = new String(message.getBody());
        System.out.println("받은 메시지: " + event);
        // 여기서 처리 로직 실행!!!!
    }, "delivery.completed"); // 이게 바로 구독 채널!!!
```
✅ `"delivery.completed"` 이벤트 채널을 구독(Subscribe) 해서, 메시지가 오면 바로 콜백 처리!!!<br>
**🔸 2. Kafka에서의 구독**<br>
Kafka는 topic(토픽)을 기반으로 구독을 해요!!
```java
@KafkaListener(topics = "delivery-complete", groupId = "sms-service")
public void handleEvent(String message) {
    // 메시지 처리 로직
    System.out.println("배송 완료 이벤트 수신: " + message);
}
```
✅ `"delivery-complete"` 토픽에 이벤트가 발행되면<br>
→ 이걸 구독한 `sms-service`가 자동으로 메시지를 받음!!!<br>
**🔸 3. RabbitMQ에서의 구독**<br>
```java
@RabbitListener(queues = "delivery.complete.queue")
public void onMessage(String message) {
    // 메시지 처리
    System.out.println("배송 완료 메시지 수신: " + message);
}
```
✅ `delivery.complete.queue`를 구독하고 있다가<br>
→ 메시지 도착 시 처리!!<br>
**✅ 어떤 식으로 동작하냐면?**
```scss
[배송 서비스] (발행자)
 └─ "배송 완료됨" 이벤트 발생 🔔

[문자 서비스] (구독자)
 └─ 이 이벤트를 구독 중이라 메시지 받음 → 고객에게 문자 발송

[포인트 서비스] (구독자)
 └─ 이 이벤트도 받음 → 포인트 적립

[통계 서비스] (구독자)
 └─ 통계에 반영
```
🔥🔥🔥 이게 바로 "관심 있는 놈들만 알아서 반응한다"는 구조!!!!!!!!!!!<br>
**💥 한 마디 정리!!!!!**
> ✅ 구독자란?<br>
이벤트에 "관심 있다"고 선언하고, 해당 이벤트 메시지를 수신해 처리하는 애들!!!

<br>

> ✅ 구독은?<br>
메시징 시스템의 채널/토픽/큐에 subscribe, listen 등을 선언해서 등록하는 방식!!!

<br>

## 트랜잭션 아웃박스 패턴

<br>

### 아웃박스 테이블 구조
- **(136)**

<br>

`CLOB`!!!!!! 이건 진짜 DB에서 큰 텍스트를 다룰 때 빠지지 않는 전설의 타입입니다요!!!!!!! 👊👊👊🔥<br>
**✅ `CLOB`란?**
> 💥 Character Large Object의 줄임말!!!!<br>
텍스트 데이터를 엄청 길~~게 저장할 수 있는 타입입니다요!!!!!

<br>

**✅ 언제 쓰냐?**
| 상황 | 왜 쓰냐 |
| --- | --- |
| JSON, XML 등 길고 복잡한 메시지 저장할 때 | 일반 VARCHAR로는 길이 제한이 있어서 부족함 ❌ |
| 로그, 이벤트 메시지, 대용량 설명 텍스트 등 | 길이 몇 KB~MB 넘어가는 데이터 처리 가능!!! |

<br>

**✅ 예시**
```sql
CREATE TABLE outbox (
  id VARCHAR2(50),
  event_type VARCHAR2(100),
  payload CLOB,
  created_at TIMESTAMP
);
```
👉 여기서 `payload`에 들어가는 건 예를 들어 이런 JSON일 수 있어요:
```json
{
  "orderId": "ORD-1234",
  "userId": "USER-9999",
  "items": [
    {"itemId": "ITEM-1", "quantity": 2},
    {"itemId": "ITEM-2", "quantity": 1}
  ],
  "totalPrice": 40000
}
```
이런 JSON은 `VARCHAR`에 안 들어갈 수도 있어서 `CLOB`이 적격!!!!!!!!!! 👑🔥<br>
**✅ DB마다 CLOB 지원 방식 (참고용)**<br>
| DBMS | 타입 이름 | 최대 크기 |
| --- | --- | --- |
| Oracle | CLOB | 최대 4GB |
| PostgreSQL | TEXT | 사실상 CLOB 기능 |
| MySQL | LONGTEXT | 최대 4GB |
| SQL Server | TEXT/NTEXT | (현재는 비권장, NVARCHAR(MAX) 사용) |

<br>

**✅ 장점 & 주의할 점**
| 장점 | 설명 |
| --- | --- |
| 📦 대용량 텍스트 저장 가능 | JSON 메시지, 로그 등 자유롭게 저장 가능 |
| 📤 메시지를 그대로 저장 가능 | 메시지 브로커에 보낼 JSON 그대로 보관 가능 |

<br>

| 단점 | 설명 |
| --- | --- |
| 🐢 성능 이슈 가능 | 읽기/쓰기 시 일반 문자열보다 느림 |
| 🔁 조작 어려움 | SQL에서 일부 문자열 추출하려면 함수 써야 함 |

<br>

**🧠 요약 헴용 정리!!**
| 항목 | 내용 |
| --- | --- |
| `CLOB`이란? | Character Large Object – 엄청 큰 텍스트 저장용 |
| 왜 필요? | 아웃박스 테이블에 JSON, XML 같은 길~~고 복잡한 메시지 저장하려고! |
| 일반 문자열 타입과 차이? | `VARCHAR`보다 훨씬 길고 크다! 최대 수 GB까지 가능! |

<br>

`payload CLOB` = 메시지 본문을 안전하게, 넉넉하게 저장하기 위한 최적의 선택!!!!!!!!
