<b>4강. 비전공자도 쉽게 이해하는 개발 심화</b><br>
<b>1. 객체의 설계도, 클래스</b><br>
<b>1. 이데아 이론으로 설명하는 클래스</b>

- 객체
    - 클래스로 먼저 정의한 후 필요할 때마다 마치 도장을 찍듯이 찍어내는 방식을 활용함
    - |클래스|인스턴스(객체)|
        |-|-|
        |등받이, 다리 4개가 있는 앉기 위한 가구<br>(의자)|우리 집에 있는 노란색 의자|
        |교통수단 중 하나이며 4개의 바퀴가 달린 물체<br>(자동차)|우리집 앞에 주차되어 있는 검은색 그랜저|

<br>

- 클래스를 모방하여 인스턴스를 생성하려면 생성자`constructor`와 new 연산자를 사용함
    - -> new 연산자로 클래스를 모방해서 만들어야 실제 메모리에 객체가 잡히게 됨

<br>

- 생성자
    - 공장
    - 인스턴스를 생성할 때 사용하는 메서드

- new 연산자
    - 전력
    - 생성자를 호출할 때 사용하는 연산자

- 클래스 ─ new 연산자 + 생성자 함수 ─> 인스턴스(객체)
    - -> 인스턴스를 통해 속성`attributes`과 메서드에 접근할 수 있음
    - (자바스크립트는 프로토타입 언어)

```java
public class Barista {

    // 속성 : 객체가 가지고 있는 특징
    String name;
    int salary;
    int coffeeTotalNum;

    // 생성자
    public Barista(String name) {
        this.name = name;
    }

    // 메서드 : 객체의 행위
    public void makeCoffee(OrderSheet order) {
        if (order.isCompleted == true) {
            return;
        }

        order.isCompleted = true;
        coffeeTotalNume += order.coffeNum;
    }

    public void showInfo() {
        System.out.println("*** 바리스타 "+name+"이 만든 총 커피의 개수는"+coffeTotalNum+" 입니다.");
    }
}
```

<br><br>

<b>2. new 연산자와 생성자</b>

```java
public class Barista {

    String name;
    int salary;
    int coffeeTotalNum;

    // 생성자
    // - 클래스와 동일한 이름을 가지고 있음
    // - 클래스 내부에 존재하는 함수이므로 메서드라고 볼 수 있음
    // - 생성자를 호출할 때 파라미터로 문자열`Stirng` 값이 들어오면, 해당 인스턴스의 name 속성에 값을 넣어 줌
    // - -> 넣어 준 이름을 name 속성으로 갖는 인스턴스가 만들어짐
    public Barista(String name) {
        this.name = name;
    }
}
```

<br>

```java
// 객체 초기화
// - 이름을 파라미터로 받아 name 속성을 설정하는 생성자 함수에 "Lee"라는 이름을 넣고 new 연산자를 통해 바리스타 인스턴스를 생성함
// - -> 생성과 동시에 값을 넣어 주는 과정
Barista baristaLee = new Barista("Lee");
baristaLee.showInfo();
```

<br>

- 만약 생성자 함수와 new 연산자가 없으면 단순히 클래스가 존재할 뿐, 실제 사용은 하지 못함
    - -> 클래스 내부에 생성자 함수를 작성하지 않는다면 인스턴스를 만들 수 없음
        - => 생성자를 따로 작성하지 않으면 자바 컴파일러가 자동적으로 만들어 냄
        - => 아무 파라미터로 입력받지 않는 형태로 자동 생성됨
        - => 클래스 내부에 작성된 생성자가 하나라도 있으면 디폴트 생성자(Default Constructor)는 자동 생성되지 않음

<br>

- 생성자는 파라미터의 개수를 달리해서 여러 개를 만들 수도 있음

<br>

```java
public class Barista {

    String name;
    int salary;
    int coffeeTotalNum;

    public Barista(String name) {
        this.name = name;
    }

    public Barista(String name, int salary) {
        this.name = name;
        this.salary = salary;
    }
}
```

<br>

```java
Barista baristaLee = new Barista("Lee");

// Barista baristaKim = new Barista();
// baristaKim.name = "Kim";
// baristaKim.salary = 3000;
Barista baristaKim = new Barista("Kim", 3000);
```

<br>

- this
    - 인스턴스에서 자기 자신을 가리키는 키워드
        - -> this.name : 이 클래스를 기반으로 생성된 바리스타 인스턴스의 name

<br>

- 클래스는 객체에 대한 설계를 바탕으로 만들어진 것이며, new 연산자를 통해 실제 객체(인스턴스)로 생성할 수 있음
- new 연산자는 객체를 만들고, 생성자 함수는 new 연산자를 사용할 때 같이 쓰는 함수임
- 생성자는 파라미터를 다르게 하여 여러 생성자를 만들 수 있음
- 생성자를 따로 적어 주지 않을 경우에는 자동으로 생성됨
    - -> 예로, Barista baristalLee = new Barista();와 같이 써 줌으로써 인스턴스를 만들 수 있음
- this는 자기 자신을 의미함
    - 파라미터와 구분 짓기 위해 this를 관례적으로 사용하고 있음
- 생성과 동시에 값을 넘겨 주는 과정을 '객체 초기화'라고 부름

<br><br>

<b>3. 객체 협력</b>

- 객체지향의 궁극적인 목적은 클래스를 잘 설계해 올바른 객체를 생성하고, 이 객체들이 서로 협력해 목표를 달성하게 만드는 것

<br>

- static
    - 정적인, 고정적인
    - 정적으로 고정되어 있는 공간에 선언한 변수
    - new 연산자로 인스턴스 객체를 만들지 않아도 바로 사용이 가능함
    - 같은 변수끼리 메모리를 공유함
    - 움직이지 않는 공간에 어떤 값을 넣어서 고정 값을 효과적으로 관리하고 싶을 때 사용함
    - 변수뿐만 아니라 메서드에도 사용이 가능함

<br>

```java
class WeirdOrderNumber {
    int num = 100;

    WeirdOrderNumber() {
        this.num++;
        System.out.println(this.num);
    }
}

public static void main(String[] args) {
    // 인스턴스 객체가 생성될 때마다 참조변수(expected01, expected02)는 서로 다른 주소 값을 갖기 때문에 101의 동일한 값만 보임
    WeirdOrderNumber expected101 = new WeirdOrderNumber(); // 101
    WeirdOrderNumber expected102 = new WeirdOrderNumber(); // 101
}
```

<br>

```java
class WeirdOrderNumber {
    static int num = 100;

    WeirdOrderNumber() {
        num++;
        System.out.println(num);
    }
}

public static void main(String[] args) {
    // 메모리를 함께 쓰고 있기 때문에 인스턴스 객체의 생성 여부와 상관이 없고 기존에 있던 값에서 계속적으로 더해지므로 직전 번호 값을 쉽게 알 수 있음
    // static 변수인 num끼리는 같은 메모리를 참조하고 있기 때문에 서로 다른 객체라 하더라고 바로 직전 값이 공유되어 어떤 값인지 알 수 있음
    WeirdOrderNumber expected101 = new WeirdOrderNumber(); // 101
    WeirdOrderNumber expected102 = new WeirdOrderNumber(); // 102
}
```

<br>

- 정적인 공간 (Static Area)
    - |static Area<br>(Method Area)|Stack Area|Heap Area|
        |-|-|-|
        |클래스<br>static<br>전역변수|함수<br>(원시 타입의 지역변수, 매개변수)<br>참조 주소 값|인스턴스<br>(new 연산자로 생성한 객체)<br>참조 타입|
        |고정적으로 존재|메서드 호출 시 메모리에 할당되고 종료되면 메모리 해제|가비지 컬렉터로 메모리 관리|
    - 프로그램의 실행부터 끝날 때까지 고정적으로 자리를 차지함

<br>

```java
// 방어 코드
// - 개발자의 의도에 맞지 않는 값이 들어올 때를 대비할 코드
// - -> 프로그램의 안정성이 증가할 수 있음
if (order.isCompleted == true) {
    return;
}
```

<br><br>

<b>4. 객체를 보호하는 접근 제어자</b>

- 접근 제어자
    - 속성에 다가갈 수 있고, 없음을 판가름해줌
    - 객체를 보호하지 않으면 외부 접근이 가능하기에 객체의 보안성이 하락하고, 프로그램이 불안정해질 때 사용함
    - 보통 클래스는 public으로 선언함
    - 클래스 내부에 있는 속성은 대부분 private으로 보호함
    - |접근 제어자||
        |-|-|
        |private|같은 클래스 내부에서만 접근 가능<br>즉, 자기 자신만 사용할 수 있음|
        |public|클래스의 외부 어디서나 접근할 수 있음|
        |default|아무것도 작성하지 않으면 자동으로 설정되는 값임<br>같은 패키지 내부에서만 접근 가능<br>-> 같은 클래스 + 같은 패키지|
        |protected|같은 패키지나 상속 관계의 클래스에서만 접근 가능<br>-> 같은 클래스 + 같은 패키지 + 상속 관계 클래스|
        - -> 같은 패키지 : 폴더 경로가 같음
        - ```
            [프로젝트 파일]
            ㄴ [src]
                ㄴ [Tea]
                    ㄴ [LemonTea.java]
                ㄴ [Coffee]
                    ㄴ [Latte.java]
                    ㄴ [Mocha.java]
                    ㄴ [Americano.java]
            ```
                - => Latte.java 파일에 default 접근 지정자를 사용한 변수는 같은 패키지 내에 있는 Americano.java 파일에서는 접근할 수 있으나, Tea 패키지 안에 있는 LemonTea.java 파일에서는 접근할 수 없음
